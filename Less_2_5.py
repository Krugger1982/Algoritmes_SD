def middle(List):
    if len(List) == 1:
        return List[0]
    return List[len(List)//2]

def GenerateBBSTArray(a):
    if len(a) < 2:
        return a
    # для дерева состоящего из более чем 1 элемента (а именно 3 и более), определим его глубину
    # так как логарифмом пользоваться нельзя
    depth = 0                       
    Number = len(a) + 1  
    while Number > 2:
        Number //= 2
        depth += 1
    result = [None] * len(a)
    a.sort()
    result[0] = middle(a)           # заполняем корень
    Level = 0                       # вводим переменную "уровень" для дальнейших рассчетов ширины среза, для корня он равен 0
    for i in range(1, len(a)):      # для всех остальных членов результирующего массива
        if i % 2 == 1:              # если индекс нечетный, то мы находимся в левом потомке
            Right = a.index(result[(i - 1) // 2])
            # берем срез массива: правая граница - это индекс в исходном массиве, где лежит ключ "родителя"
            Left = Right - (2 ** (depth - Level))  + 1
            # а левая граница среза  отстоит от правой на количество элементов в ветке, т.е. на (2**(depth - Level)-1)
        else:                       # если индекс четный - мы находимся в правом потомке
            Left = a.index(result[(i - 2) // 2]) + 1
            Right = Left + (2 ** (depth - Level)) - 1
            # берем срез массива: левая граница - это индекс родителя  + 1
            # а правая граница среза  отстоит от левой на количество элементов в ветке, т.е. на (2**(depth - Level)-1
        result[i] = middle(a[Left : Right])

        if (i + 2) & (i + 1) == 0:          # если индекс является (2**n)-2, то мы прошли до самого правого элемента текущего уровня
            Level += 1                      # сдвинем параметр уровня    
    return result
